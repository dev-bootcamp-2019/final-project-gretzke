pragma solidity 0.4.24;
// pragma experimental ABIEncoderV2;

/// @title Marketplace
/// @author Daniel Gretzke
contract Marketplace {
    
    // owner, admin, storeOwner variables
    address public owner;
    mapping(address => bool) public admins;
    mapping(address => bool) public storeOwners;

    // events
    event addedAdmin(address indexed admin);
    event removedAdmin(address indexed admin);
    event addedStoreOwner(address indexed storeOwner, address indexed admin);
    event removedStoreOwner(address indexed storeOwner, address indexed admin);
    
    event addedStore(address indexed storeOwner, bytes32 indexed storeID);
    event removedStore(address indexed storeOwner, bytes32 indexed storeID);
    event addedItem(address indexed storeOwner, bytes32 indexed storeID, bytes32 indexed itemID);
    event removedItem(address indexed storeOwner, bytes32 indexed storeID, bytes32 indexed itemID);

    // store and item structs
    struct Store {
        bytes32 storeID;
        string name;
        string description;
        // items are stored inside a mapping, mapped from a bytes32 key to an item
        mapping(bytes32 => Item) items;
        // items can be retreived via an unordered array of bytes32 keys
        bytes32[] itemIdList;
        // index inside storeIdList array for cheap deletion of stores
        uint256 index;
        bool active;
    }

    struct Item {
        string name;
        string description;
        // ipfs hash (placeholder, needs to be adjusted to real ipfs hashes)
        bytes32 image;
        uint256 price;
        // index inside itemIdList array for cheap deletion of items
        uint256 index;
        bool active;
    }
    
    // stores are stored inside a mapping, mapped from a bytes32 key to a store
    // each storeOwner has its own mapping to store stores in
    mapping(address => mapping(bytes32 => Store)) private stores;
    // stores can be retreived via an unordered array of bytes32 keys
    mapping(address => bytes32[]) private storeIdLists;
    // fixed size array to store featured storeOwners inside the marketplace
    address[10] public featuredStoreOwners;

    // balances of storeOwners
    mapping(address => uint256) public balances;

    /// @dev modifier, verifies that caller is owner
    modifier onlyOwner() {
        require(owner == msg.sender, "caller is not owner");
        _;
    }

    /// @dev modifier, verifies that caller is admin
    modifier onlyAdmin() {
        require(admins[msg.sender], "caller is not admin");
        _;
    }

    /// @dev modifier, verifies that caller is store owner
    modifier onlyStoreOwner() {
        require(storeOwners[msg.sender], "caller is not store owner");
        _;
    }
    
    /// @dev constructor 
    constructor() public {
        owner = msg.sender;
    }

    /// @notice add administrator
    /// @dev only callable by owner
    /// @param _newAdmin address of account to be added as administrator
    function addAdmin(address _newAdmin) external onlyOwner {
        // only emit event if admin is not added yet
        if (!admins[_newAdmin]) {
            emit addedAdmin(_newAdmin);
        }
        admins[_newAdmin] = true;
    }

    /// @notice remove administrator
    /// @dev only callable by owner
    /// @param _admin address of account to be removed as administrator
    function removeAdmin(address _admin) external onlyOwner {
        // only emit event if admin is not removed yet
        if (admins[_admin]) {
            emit removedAdmin(_admin);
        }
        admins[_admin] = false;
    }

    /// @notice add shopowner
    /// @dev only callable by admins
    /// @param _newStoreOwner address of account to be added as shopowner
    function addStoreOwner(address _newStoreOwner) external onlyAdmin {
        // only emit event if shopowner is not added yet
        if (!storeOwners[_newStoreOwner]) {
            emit addedStoreOwner(_newStoreOwner, msg.sender);
        }
        storeOwners[_newStoreOwner] = true;
    }

    /// @notice remove shopowner
    /// @dev only callable by admins
    /// @param _storeOwner address of account to be removed as shopowner
    function removeStoreOwner(address _storeOwner) external onlyAdmin {
        // only emit event if shopowner is not removed yet
        if (storeOwners[_storeOwner]) {
            emit removedStoreOwner(_storeOwner, msg.sender);
        }
        storeOwners[_storeOwner] = false;
    }

    /// @notice adds a new store
    /// @dev only callable by store owners, throws on duplicate store names per store owner
    /// @param _name name of store
    /// @param _description description of store
    /// @return generated bytes32 ID of store 
    function addStore(string _name, string _description) public onlyStoreOwner returns(bytes32 ID) {
        // generate out of name, only allow one specific store name per store owner
        ID = keccak256(abi.encodePacked(_name));

        // ensure that there is no active store with same ID
        require(!stores[msg.sender][ID].active, "store with same name/id already active");

        // push newly generated ID to store id list
        uint256 index = storeIdLists[msg.sender].push(ID) - 1;

        // generate new store in stores mapping
        stores[msg.sender][ID] = Store({
            storeID: ID,
            name: _name,
            description: _description,
            itemIdList: new bytes32[](0),
            index: index,
            active: true
        });

        emit addedStore(msg.sender, ID);
    }
    function removeStore() public onlyStoreOwner {}

    function addItem(bytes32 _storeID) public onlyStoreOwner {}
    function removeItem(bytes32 _storeID) public onlyStoreOwner {}
    
    /// @notice return list of stores belonging to a store owner
    /// @param _storeOwner address of store owner
    /// @return bytes32 array, containing IDs of stores belonging to store owner 
    function getStoreIdList(address _storeOwner) public view returns(bytes32[]) {
        return storeIdLists[_storeOwner];
    }

    /// @notice return store by store ID belonging to a store owner
    /// @param _storeOwner address of store owner
    /// @param _storeID bytes32 ID of store
    /// @return name of store
    /// @return description of store
    /// @return bytes32 array of item IDs belongig to store
    /// @return index of store in store id list
    function getStore(address _storeOwner, bytes32 _storeID) public view returns(
        string name, 
        string description, 
        bytes32[] itemIdList, 
        uint256 index
    ) {
        Store memory store = stores[_storeOwner][_storeID];
        name = store.name;
        description = store.description;
        itemIdList = store.itemIdList;
        index = store.index;
    }

    /// @notice return item list of store belonging to a store owner
    /// @param _storeOwner address of store owner
    /// @param _storeID bytes32 ID of store
    /// @return bytes32 array, containing item IDs of a store belonging to store owner 
    function getItemIdList(address _storeOwner, bytes32 _storeID) public view returns(bytes32[]) {
        return stores[_storeOwner][_storeID].itemIdList;
    }

    /// @notice return item of a store belonging to a store owner
    /// @param _storeOwner address of store owner
    /// @param _storeID bytes32 ID of store
    /// @return name of item
    /// @return description of item
    /// @return ipfs hash of image
    /// @return price of item
    /// @return index of item in item id list
    function getItem(address _storeOwner, bytes32 _storeID, bytes32 _itemID) public view returns(
        string name,
        string description,
        bytes32 image,
        uint256 price,
        uint256 index
    ) {
        Item memory item = stores[_storeOwner][_storeID].items[_itemID];
        name = item.name;
        description = item.description;
        image = item.image;
        price = item.price;
        index = item.index;
    }

}